{
  "abstract": false,
  "anchor": "#file-multitasking.md",
  "category": "files",
  "const": false,
  "definition": "",
  "explicit": false,
  "fullname": "multitasking.md",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "inline": false,
  "kind": "file",
  "location": {
    "column": 0,
    "file": "docs/tutorials/topical/multitasking.md",
    "line": 0
  },
  "name": "multitasking.md",
  "override": false,
  "parent": null,
  "programlisting": "\\page multitasking Multitasking\n\n\\note\nFor a full list of functions for interacting with Tasks, see its\n[C API](@ref c-rtos) and [C++ API](@ref cpp-rtos).\nTasks are a great tool to do multiple things at once, but they can be\ndifficult to use properly. The most important thing to remember when\nusing tasks is that tasks aren't truly running in the background - they\nare run one at a time and swapped out by the PROS scheduler. If your\ntask performs some repeated action (e.g. a `while` loop), you should\ninclude a `delay()` or `task_delay_until()`. Without a `delay()`\nstatement, your task could starve the processor of resources and prevent\nthe kernel from running properly.\n\nThe PROS task scheduler is a preemptive, priority-based, round-robin\nscheduler. This means that tasks are preempted (interrupted) every\nmillisecond to determine if another task ought to run. PROS decides\nwhich task to run next based on all of the ready tasks' priorities.\n\n> - Tasks which are eligible for execution are called \"ready.\" Tasks\n>   are typically not ready because they may be sleeping (in a\n>   `task_delay`) or blocked waiting for a synchronization mechanism\n>   (e.g. a mutex or semaphore).\n> - The higher the priority, the more crucial the task is considered,\n>   and more CPU time will be awarded to the task. Ready tasks of\n>   higher priority will always run in preference to lower priority\n>   tasks.\n> - Tasks of equal priority take preference when a task is preempted.\n>   In other words, if tasks A and B have equal priority, then when A\n>   is interrupted, B will run next, even if A is still eligible for\n>   execution. This is called round-robin scheduling.\n\n## On the Abuse of Tasks\n\nTasks are very often misused and abused in ways that make the PROS\nkernel behave in unintended ways. The following list are some commonly\nmade mistakes and guidelines for using Tasks in PROS.\n\n> - Tasks in real-time operating systems should be long-living. That\n>   is, tasks should not typically perform a short operation and then\n>   die. Consider re-working the logic of your program to enable such\n>   behavior.\n> - \"Task functions\" are not special, except that their signature\n>   needs to be correct. In other programming environments for VEX,\n>   tasks must be marked with a special keyword. With most modern\n>   programming environments, tasks are just functions that get\n>   executed asynchronously.\n> - It was mentioned above, but it's important enough for a second\n>   mention: every tasks' loop should have a `delay()` statement.\n\n### Task Management\n\nTasks in PROS are simple to create:\n\nThe [task_create](../../api/c/rtos.html#task_create) function takes in\na function where the task starts, an argument to the function, a\npriority for the task, and two new fields not yet discussed: stack size\nand name.\n\nStack size describes the amount of stack space that is allocated for the\ntask. The stack is an area for your program to store variables, return\naddresses for functions, and more. Real-time operating systems like PROS\nwork in limited-memory situations and do not allow for a dynamically\nresizable stack. Modern desktop operating systems do not need to worry\nabout stack space as much as you would in a RTOS. The good news is that\nmost tasks should opt to use `TASK_STACK_DEPTH_DEFAULT`, which should\nprovide ample stack space for nearly any task. Very rudimentary and\nsimple tasks (e.g. not many nested functions, no floating point context,\nfew variables, only C) may be able to use `TASK_STACK_DEPTH_MIN`.\n\nThe last parameter is the task name. The task name allows you to give a\ntask a human-friendly name for the task. It is primarily for debugging\npurposes and allows you (the human) to easily identify tasks if\nperforming advanced task management. Task names may be up to 32\ncharacters long, and you may pass NULL or an empty string into the\nfunction. In API2,\n[taskCreate](../../../cortex/api/index.html#taskCreate) will\nautomatically make the task name an empty string.\n\n### Synchronization\n\nOne problem which one often runs into when dealing with tasks is the\nproblem of synchronization. If two tasks try to read the same sensor or\ncontrol the same motor at the same time, unexpected behavior may occur\nsince two tasks are trying to write to the same piece of data or\nvariable (i.e. [race\nconditions](https://en.wikipedia.org/wiki/Race_condition#Software)). The\nconcept of writing code which has protections against race conditions is\ncalled thread safety. There are many different ways to implement thread\nsafety, and PROS has several facilities to help maintain thread safety.\n\nThe simplest way to ensure thread safety is to design tasks which will\nnever access the same variables or data. You may design your code to\nhave each subsystem of your robot in its own task. Ensuring that tasks\nnever write to the same variables is called division of responsibility\nor separation of domain.\n\n```{.c}\nint task1_variable = 0;\nvoid Task1(void * ignore) {\n    // do things\n    task1_variable = 4;\n}\n\nvoid Task2(void * ignore) {\n  // do things\n  // I can read task1_variable, but NOT write to it\n  printf(\"%d\\n\", task1_variable);\n}\n```\n\nSometimes this is impossible: suppose you wanted to write a PID\ncontroller on its own task and you wanted to change the target of the\nPID controller. PROS features two types of synchronization structures,\n_mutexes_ and _notifications_ that can be used to coordinate tasks.\n\n## Mutexes\n\nMutexes stand for mutual exclusion; only one task can hold a mutex at\nany given time. Other tasks must wait for the first task to finish (and\nrelease the mutex) before they may continue.\n\nMutexes do not magically prevent concurrent writing, but provide the\nability for tasks to create \"contracts\" with each other. You can write\nyour code such that a variable is never written to unless the task owns\na mutex designated for that variable.\n\n## Notifications\n\nTask notifications are a powerful new feature in PROS 3 which allows\ndirect-to-task synchronization. A full tutorial on task notifications\ncan be found @ref notifications.",
  "refid": "multitasking_8md",
  "static": false,
  "strong": false,
  "title": "multitasking.md",
  "url": "multitasking_8md.md#file-multitasking.md",
  "visibility": "public"
}