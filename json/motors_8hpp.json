{
  "abstract": false,
  "anchor": "#file-motors.hpp",
  "category": "files",
  "const": false,
  "copyright": [
    "(c) 2017-2018, Purdue University ACM SIGBots."
  ],
  "definition": "",
  "details": "Contains prototypes for the V5 Motor-related functions.\n\nVisit [https://pros.cs.purdue.edu/v5/tutorials/topical/motors.html](https://pros.cs.purdue.edu/v5/tutorials/topical/motors.html) to learn more.\n\nThis file should not be modified by users, since it gets replaced whenever a kernel upgrade occurs.\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at [http://mozilla.org/MPL/2.0/](http://mozilla.org/MPL/2.0/). ",
  "explicit": false,
  "fullname": "pros/motors.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": true,
  "includes": "<cstdint>",
  "inline": false,
  "kind": "file",
  "location": {
    "column": 0,
    "file": "pros/motors.hpp",
    "line": 0
  },
  "name": "pros/motors.hpp",
  "namespaces": [
    {
      "anchor": "",
      "brief": "Get the current status of the competition control. ",
      "category": "namespaces",
      "fullname": "pros",
      "kind": "namespace",
      "name": "pros",
      "refid": "namespacepros",
      "summary": "Get the current status of the competition control. ",
      "title": "pros",
      "url": "namespacepros.md",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "pros::literals",
      "kind": "namespace",
      "name": "pros::literals",
      "refid": "namespacepros_1_1literals",
      "title": "pros::literals",
      "url": "namespacepros_1_1literals.md",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-pros",
    "category": "dirs",
    "fullname": "pros",
    "kind": "dir",
    "name": "pros",
    "refid": "dir_214b722ca0199f3055230149c608b806",
    "title": "pros",
    "url": "dir_214b722ca0199f3055230149c608b806.md#dir-pros",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-pros",
      "category": "dirs",
      "fullname": "pros",
      "kind": "dir",
      "name": "pros",
      "refid": "dir_214b722ca0199f3055230149c608b806",
      "title": "pros",
      "url": "dir_214b722ca0199f3055230149c608b806.md#dir-pros",
      "visibility": "public"
    }
  ],
  "programlisting": "/**\n * \\file pros/motors.hpp\n *\n * Contains prototypes for the V5 Motor-related functions.\n *\n * Visit https://pros.cs.purdue.edu/v5/tutorials/topical/motors.html to learn\n * more.\n *\n * This file should not be modified by users, since it gets replaced whenever\n * a kernel upgrade occurs.\n *\n * \\copyright (c) 2017-2018, Purdue University ACM SIGBots.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n#ifndef _PROS_MOTORS_HPP_\n#define _PROS_MOTORS_HPP_\n\n#include <cstdint>\n#include \"pros/motors.h\"\n\nnamespace pros {\nclass Motor {\n    public:\n    /**\n     * Creates a Motor object for the given port and specifications.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENXIO - The given value is not within the range of V5 ports (1-21).\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param port\n     *        The V5 port number from 1-21\n     * \\param gearset\n     *        The motor's gearset\n     * \\param reverse\n     *        True reverses the motor, false is default\n     * \\param encoder_units\n     *        The motor's encoder units\n     */\n    explicit Motor(const std::uint8_t port, const motor_gearset_e_t gearset, const bool reverse,\n                   const motor_encoder_units_e_t encoder_units);\n\n    explicit Motor(const std::uint8_t port, const motor_gearset_e_t gearset, const bool reverse);\n\n    explicit Motor(const std::uint8_t port, const motor_gearset_e_t gearset);\n\n    explicit Motor(const std::uint8_t port, const bool reverse);\n\n    explicit Motor(const std::uint8_t port);\n\n    /****************************************************************************/\n    /**                         Motor movement functions                       **/\n    /**                                                                        **/\n    /**          These functions allow programmers to make motors move         **/\n    /****************************************************************************/\n    /**\n     * Sets the voltage for the motor from -128 to 127.\n     *\n     * This is designed to map easily to the input from the controller's analog\n     * stick for simple opcontrol use. The actual behavior of the motor is\n     * analogous to use of pros::Motor::move(), or motorSet from the PROS 2 API.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param voltage\n     *        The new motor voltage from -127 to 127\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t operator=(std::int32_t voltage) const;\n\n    /**\n     * Sets the voltage for the motor from -127 to 127.\n     *\n     * This is designed to map easily to the input from the controller's analog\n     * stick for simple opcontrol use. The actual behavior of the motor is\n     * analogous to use of motor_move(), or motorSet() from the PROS 2 API.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param voltage\n     *        The new motor voltage from -127 to 127\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t move(std::int32_t voltage) const;\n\n    /**\n     * Sets the target absolute position for the motor to move to.\n     *\n     * This movement is relative to the position of the motor when initialized or\n     * the position when it was most recently reset with\n     * pros::Motor::set_zero_position().\n     *\n     * \\note This function simply sets the target for the motor, it does not block\n     * program execution until the movement finishes.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param position\n     *        The absolute position to move to in the motor's encoder units\n     * \\param velocity\n     *        The maximum allowable velocity for the movement in RPM\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t move_absolute(const double position, const std::int32_t velocity) const;\n\n    /**\n     * Sets the relative target position for the motor to move to.\n     *\n     * This movement is relative to the current position of the motor as given in\n     * pros::Motor::motor_get_position(). Providing 10.0 as the position parameter\n     * would result in the motor moving clockwise 10 units, no matter what the\n     * current position is.\n     *\n     * \\note This function simply sets the target for the motor, it does not block\n     * program execution until the movement finishes.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param position\n     *        The relative position to move to in the motor's encoder units\n     * \\param velocity\n     *        The maximum allowable velocity for the movement in RPM\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t move_relative(const double position, const std::int32_t velocity) const;\n\n    /**\n     * Sets the velocity for the motor.\n     *\n     * This velocity corresponds to different actual speeds depending on the\n     * gearset used for the motor. This results in a range of +-100 for\n     * E_MOTOR_GEARSET_36, +-200 for E_MOTOR_GEARSET_18, and +-600 for\n     * E_MOTOR_GEARSET_6. The velocity is held with PID to ensure consistent\n     * speed, as opposed to setting the motor's voltage.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param velocity\n     *        The new motor velocity from -+-100, +-200, or +-600 depending on the\n     *        motor's gearset\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t move_velocity(const std::int32_t velocity) const;\n\n    /**\n     * Sets the output voltage for the motor from -12000 to 12000 in millivolts.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param port\n     *        The V5 port number from 1-21\n     * \\param voltage\n     *        The new voltage value from -12000 to 12000\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t move_voltage(const std::int32_t voltage) const;\n\n    /**\n     * Changes the output velocity for a profiled movement (motor_move_absolute()\n     * or motor_move_relative()). This will have no effect if the motor is not\n     * following a profiled movement.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param velocity\n     *        The new motor velocity from +-100, +-200, or +-600 depending on the\n     *        motor's gearset\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t modify_profiled_velocity(const std::int32_t velocity) const;\n\n    /**\n     * Gets the target position set for the motor by the user.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The target position in its encoder units or PROS_ERR_F if the\n     * operation failed, setting errno.\n     */\n    virtual double get_target_position(void) const;\n\n    /**\n     * Gets the velocity commanded to the motor by the user.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The commanded motor velocity from +-100, +-200, or +-600, or\n     * PROS_ERR if the operation failed, setting errno.\n     */\n    virtual std::int32_t get_target_velocity(void) const;\n\n    /****************************************************************************/\n    /**                        Motor telemetry functions                       **/\n    /**                                                                        **/\n    /**    These functions allow programmers to collect telemetry from motors  **/\n    /****************************************************************************/\n\n    /**\n     * Gets the actual velocity of the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's actual velocity in RPM or PROS_ERR_F if the operation\n     * failed, setting errno.\n     */\n    virtual double get_actual_velocity(void) const;\n\n    /**\n     * Gets the current drawn by the motor in mA.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's current in mA or PROS_ERR if the operation failed,\n     * setting errno.\n     */\n    virtual std::int32_t get_current_draw(void) const;\n\n    /**\n     * Gets the direction of movement for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return 1 for moving in the positive direction, -1 for moving in the\n     * negative direction, and PROS_ERR if the operation failed, setting errno.\n     */\n    virtual std::int32_t get_direction(void) const;\n\n    /**\n     * Gets the efficiency of the motor in percent.\n     *\n     * An efficiency of 100% means that the motor is moving electrically while\n     * drawing no electrical power, and an efficiency of 0% means that the motor\n     * is drawing power but not moving.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's efficiency in percent or PROS_ERR_F if the operation\n     * failed, setting errno.\n     */\n    virtual double get_efficiency(void) const;\n\n    /**\n     * Checks if the motor is drawing over its current limit.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return 1 if the motor's current limit is being exceeded and 0 if the\n     * current limit is not exceeded, or PROS_ERR if the operation failed, setting\n     * errno.\n     */\n    virtual std::int32_t is_over_current(void) const;\n\n    /**\n     * Checks if the motor is stopped.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\note Although this function forwards data from the motor, the motor\n     * presently does not provide any value. This function returns PROS_ERR with\n     * errno set to ENOSYS.\n     *\n     * \\return 1 if the motor is not moving, 0 if the motor is moving, or PROS_ERR\n     * if the operation failed, setting errno\n     */\n    virtual std::int32_t is_stopped(void) const;\n\n    /**\n     * Checks if the motor is at its zero position.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\note Although this function forwards data from the motor, the motor\n     * presently does not provide any value. This function returns PROS_ERR with\n     * errno set to ENOSYS.\n     *\n     * \\return 1 if the motor is at zero absolute position, 0 if the motor has\n     * moved from its absolute zero, or PROS_ERR if the operation failed, setting\n     * errno\n     */\n    virtual std::int32_t get_zero_position_flag(void) const;\n\n    /**\n     * Gets the faults experienced by the motor.\n     *\n     * Compare this bitfield to the bitmasks in pros::motor_fault_e_t.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param port\n     *        The V5 port number from 1-21\n     *\n     * \\return A bitfield containing the motor's faults.\n     */\n    virtual std::uint32_t get_faults(void) const;\n\n    /**\n     * Gets the flags set by the motor's operation.\n     *\n     * Compare this bitfield to the bitmasks in pros::motor_flag_e_t.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param port\n     *        The V5 port number from 1-21\n     *\n     * \\return A bitfield containing the motor's flags.\n     */\n    virtual std::uint32_t get_flags(void) const;\n\n    /**\n     * Gets the raw encoder count of the motor at a given timestamp.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param[in] timestamp\n     *            A pointer to a time in milliseconds for which the encoder count\n     *            will be returned. If NULL, the timestamp at which the encoder\n     *            count was read will not be supplied\n     *\n     * \\return The raw encoder count at the given timestamp or PROS_ERR if the\n     * operation failed.\n     */\n    virtual std::int32_t get_raw_position(std::uint32_t* const timestamp) const;\n\n    /**\n     * Gets the temperature limit flag for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return 1 if the temperature limit is exceeded and 0 if the temperature is\n     * below the limit, or PROS_ERR if the operation failed, setting errno.\n     */\n    virtual std::int32_t is_over_temp(void) const;\n\n    /**\n     * Gets the absolute position of the motor in its encoder units.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's absolute position in its encoder units or PROS_ERR_F\n     * if the operation failed, setting errno.\n     */\n    virtual double get_position(void) const;\n\n    /**\n     * Gets the power drawn by the motor in Watts.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's power draw in Watts or PROS_ERR_F if the operation\n     * failed, setting errno.\n     */\n    virtual double get_power(void) const;\n\n    /**\n     * Gets the temperature of the motor in degrees Celsius.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's temperature in degrees Celsius or PROS_ERR_F if the\n     * operation failed, setting errno.\n     */\n    virtual double get_temperature(void) const;\n\n    /**\n     * Gets the torque generated by the motor in Newton Meters (Nm).\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's torque in Nm or PROS_ERR_F if the operation failed,\n     * setting errno.\n     */\n    virtual double get_torque(void) const;\n\n    /**\n     * Gets the voltage delivered to the motor in millivolts.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's voltage in mV or PROS_ERR_F if the operation failed,\n     * setting errno.\n     */\n    virtual std::int32_t get_voltage(void) const;\n\n    /****************************************************************************/\n    /**                      Motor configuration functions                     **/\n    /**                                                                        **/\n    /**  These functions allow programmers to configure the behavior of motors **/\n    /****************************************************************************/\n\n    /**\n     * Sets the position for the motor in its encoder units.\n     *\n     * This will be the future reference point for the motor's \"absolute\"\n     * position.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param position\n     *        The new reference position in its encoder units\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_zero_position(const double position) const;\n\n    /**\n     * Sets the \"absolute\" zero position of the motor to its current position.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t tare_position(void) const;\n\n    /**\n     * Sets one of motor_brake_mode_e_t to the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param mode\n     *        The motor_brake_mode_e_t to set for the motor\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_brake_mode(const motor_brake_mode_e_t mode) const;\n\n    /**\n     * Sets the current limit for the motor in mA.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param limit\n     *        The new current limit in mA\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_current_limit(const std::int32_t limit) const;\n\n    /**\n     * Sets one of motor_encoder_units_e_t for the motor encoder.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param units\n     *        The new motor encoder units\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_encoder_units(const motor_encoder_units_e_t units) const;\n\n    /**\n     * Sets one of motor_gearset_e_t for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param gearset\n     *        The new motor gearset\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_gearing(const motor_gearset_e_t gearset) const;\n\n    /**\n     * Takes in floating point values and returns a properly formatted pid struct.\n     * The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is\n     * 2.0625, etc.\n     * This function will convert the floating point values to the nearest 4.4\n     * value.\n     *\n     * \\param kf\n     *        The feedforward constant\n     * \\param kp\n     *        The proportional constant\n     * \\param ki\n     *        The integral constant\n     * \\param kd\n     *        The derivative constant\n     *\n     * \\return A motor_pid_s_t struct formatted properly in 4.4.\n     */\n    static motor_pid_s_t convert_pid(double kf, double kp, double ki, double kd);\n\n    /**\n     * Takes in floating point values and returns a properly formatted pid struct.\n     * The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is\n     * 2.0625, etc.\n     * This function will convert the floating point values to the nearest 4.4\n     * value.\n     *\n     * \\param kf\n     *        The feedforward constant\n     * \\param kp\n     *        The proportional constant\n     * \\param ki\n     *        The integral constant\n     * \\param kd\n     *        The derivative constant\n     * \\param filter\n     *        A constant used for filtering the profile acceleration\n     * \\param limit\n     *        The integral limit\n     * \\param threshold\n     *        The threshold for determining if a position movement has reached its\n     *        goal. This has no effect for velocity PID calculations.\n     * \\param loopspeed\n     *        The rate at which the PID computation is run in ms\n     *\n     * \\return A motor_pid_s_t struct formatted properly in 4.4.\n     */\n    static motor_pid_full_s_t convert_pid_full(double kf, double kp, double ki, double kd, double filter, double limit,\n                                               double threshold, double loopspeed);\n\n    /**\n     * Sets one of motor_pid_s_t for the motor. This intended to just modify the\n     * main PID constants.\n     *\n     * Only non-zero values of the struct will change the existing motor\n     * constants.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param pid\n     *        The new motor PID constants\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_pos_pid(const motor_pid_s_t pid) const;\n\n    /**\n     * Sets one of motor_pid_full_s_t for the motor.\n     *\n     * Only non-zero values of the struct will change the existing motor\n     * constants.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param pid\n     *        The new motor PID constants\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_pos_pid_full(const motor_pid_full_s_t pid) const;\n\n    /**\n     * Sets one of motor_pid_s_t for the motor. This intended to just modify the\n     * main PID constants.\n     *\n     * Only non-zero values of the struct will change the existing motor\n     * constants.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param pid\n     *        The new motor PID constants\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_vel_pid(const motor_pid_s_t pid) const;\n\n    /**\n     * Sets one of motor_pid_full_s_t for the motor.\n     *\n     * Only non-zero values of the struct will change the existing motor\n     * constants.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param pid\n     *        The new motor PID constants\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_vel_pid_full(const motor_pid_full_s_t pid) const;\n\n    /**\n     * Sets the reverse flag for the motor.\n     *\n     * This will invert its movements and the values returned for its position.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param reverse\n     *        True reverses the motor, false is default\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_reversed(const bool reverse) const;\n\n    /**\n     * Sets the voltage limit for the motor in Volts.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\param limit\n     *        The new voltage limit in Volts\n     *\n     * \\return 1 if the operation was successful or PROS_ERR if the operation\n     * failed, setting errno.\n     */\n    virtual std::int32_t set_voltage_limit(const std::int32_t limit) const;\n\n    /**\n     * Gets the brake mode that was set for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return One of motor_brake_mode_e_t, according to what was set for the\n     * motor, or E_MOTOR_BRAKE_INVALID if the operation failed, setting errno.\n     */\n    virtual motor_brake_mode_e_t get_brake_mode(void) const;\n\n    /**\n     * Gets the current limit for the motor in mA.\n     *\n     * The default value is 2500 mA.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's current limit in mA or PROS_ERR if the operation failed,\n     * setting errno.\n     */\n    virtual std::int32_t get_current_limit(void) const;\n\n    /**\n     * Gets the encoder units that were set for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return One of motor_encoder_units_e_t according to what is set for the\n     * motor or E_MOTOR_ENCODER_INVALID if the operation failed.\n     */\n    virtual motor_encoder_units_e_t get_encoder_units(void) const;\n\n    /**\n     * Gets the gearset that was set for the motor.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return One of motor_gearset_e_t according to what is set for the motor,\n     * or E_GEARSET_INVALID if the operation failed.\n     */\n    virtual motor_gearset_e_t get_gearing(void) const;\n\n    /**\n     * Gets the position PID that was set for the motor. This function will return\n     * zero for all of the parameters if the motor_set_pos_pid() or\n     * motor_set_pos_pid_full() functions have not been used.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * Additionally, in an error state all values of the returned struct are set\n     * to their negative maximum values.\n     *\n     * \\return A motor_pid_full_s_t containing the position PID constants last set\n     * to the given motor\n     */\n    virtual motor_pid_full_s_t get_pos_pid(void) const;\n\n    /**\n     * Gets the velocity PID that was set for the motor. This function will return\n     * zero for all of the parameters if the motor_set_vel_pid() or\n     * motor_set_vel_pid_full() functions have not been used.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * Additionally, in an error state all values of the returned struct are set\n     * to their negative maximum values.\n     *\n     * \\return A motor_pid_full_s_t containing the velocity PID constants last set\n     * to the given motor\n     */\n    virtual motor_pid_full_s_t get_vel_pid(void) const;\n\n    /**\n     * Gets the operation direction of the motor as set by the user.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return 1 if the motor has been reversed and 0 if the motor was not\n     * reversed, or PROS_ERR if the operation failed, setting errno.\n     */\n    virtual std::int32_t is_reversed(void) const;\n\n    /**\n     * Gets the voltage limit set by the user.\n     *\n     * Default value is 0V, which means that there is no software limitation\n     * imposed on the voltage.\n     *\n     * This function uses the following values of errno when an error state is\n     * reached:\n     * ENODEV - The port cannot be configured as a motor\n     *\n     * \\return The motor's voltage limit in V or PROS_ERR if the operation failed,\n     * setting errno.\n     */\n    virtual std::int32_t get_voltage_limit(void) const;\n\n    /**\n     * Gets the port number of the motor.\n     *\n     * \\return The motor's port number.\n     */\n    virtual std::uint8_t get_port(void) const;\n\n    private:\n    const std::uint8_t _port;\n};\n\nnamespace literals {\nconst pros::Motor operator\"\" _mtr(const unsigned long long int m);\nconst pros::Motor operator\"\" _rmtr(const unsigned long long int m);\n}  // namespace literals\n}  // namespace pros\n#endif  // _PROS_MOTORS_HPP_",
  "publicClasses": [
    {
      "anchor": "",
      "category": "classes",
      "fullname": "pros::Motor",
      "kind": "class",
      "name": "pros::Motor",
      "refid": "classpros_1_1Motor",
      "title": "pros::Motor",
      "url": "classpros_1_1Motor.md",
      "visibility": "public"
    }
  ],
  "publicFunctions": [
    {
      "abstract": false,
      "anchor": "#function-operator\"\"_mtr",
      "argsString": "(const unsigned long long int m)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "const pros::Motor pros::literals::operator\"\"_mtr",
      "deleted": false,
      "explicit": false,
      "fullname": "motors.hpp::operator\"\"_mtr",
      "hasDetails": false,
      "inline": false,
      "kind": "function",
      "location": {
        "column": 19,
        "file": "pros/motors.hpp",
        "line": 829
      },
      "name": "operator\"\"_mtr",
      "override": false,
      "params": [
        {
          "name": "m",
          "type": "const unsigned long long int",
          "typePlain": "const unsigned long long int"
        }
      ],
      "pureVirtual": false,
      "refid": "namespacepros_1_1literals_1af2d5211b971e03e0fa4e072cf8bf91a0",
      "static": false,
      "strong": false,
      "title": "operator\"\"_mtr",
      "type": "const [pros::Motor](classpros_1_1Motor.md)",
      "typePlain": "const pros::Motor",
      "url": "motors_8hpp.md#function-operator\"\"_mtr",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-operator\"\"_rmtr",
      "argsString": "(const unsigned long long int m)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "const pros::Motor pros::literals::operator\"\"_rmtr",
      "deleted": false,
      "explicit": false,
      "fullname": "motors.hpp::operator\"\"_rmtr",
      "hasDetails": false,
      "inline": false,
      "kind": "function",
      "location": {
        "column": 19,
        "file": "pros/motors.hpp",
        "line": 830
      },
      "name": "operator\"\"_rmtr",
      "override": false,
      "params": [
        {
          "name": "m",
          "type": "const unsigned long long int",
          "typePlain": "const unsigned long long int"
        }
      ],
      "pureVirtual": false,
      "refid": "namespacepros_1_1literals_1ad6eb4fc1b6d77963aa9709725d368468",
      "static": false,
      "strong": false,
      "title": "operator\"\"_rmtr",
      "type": "const [pros::Motor](classpros_1_1Motor.md)",
      "typePlain": "const pros::Motor",
      "url": "motors_8hpp.md#function-operator\"\"_rmtr",
      "virtual": false,
      "visibility": "public"
    }
  ],
  "refid": "motors_8hpp",
  "static": false,
  "strong": false,
  "title": "pros/motors.hpp",
  "url": "motors_8hpp.md#file-motors.hpp",
  "visibility": "public"
}